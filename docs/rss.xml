<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Tasfa1tals的博客</title><link>https://hyjtab.github.io</link><description>人们应当想象，西西弗是快乐的</description><copyright>Tasfa1tals的博客</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://hyjtab.github.io/avatar.jpg</url><title>avatar</title><link>https://hyjtab.github.io</link></image><lastBuildDate>Tue, 21 Jan 2025 15:53:57 +0000</lastBuildDate><managingEditor>Tasfa1tals的博客</managingEditor><ttl>60</ttl><webMaster>Tasfa1tals的博客</webMaster><item><title>垃圾回收</title><link>https://hyjtab.github.io/post/14.html</link><description># 分代垃圾回收

对象首先分配在伊甸园区域

新生代空间不足时，触发minor gc, 伊甸园和from错货的对象使用copy复制到to中，存活的对象年龄+1，并交换from，to

minor gc会引发stop the world,暂停其他用户的线程，等待垃圾回收结束，用户线程才恢复运行

当对象寿命超过阈值时，会晋升至老年代，最大寿命是15，不同垃圾回收器不足

当老年代空间不足，会先尝试触发minorgc，如果还不足，则会触发一次full gc STW时间更长

## 相关参数

堆初始化大小            -Xms

堆最大大小                -Xmx或-XX:MaxHeapSize=size

新生代大小                -Xmm或 （-XX:NewSize=size+-XX:MaxNewSize=size）

幸存区比例（动态） -XX:IntialSurvivorRatio=ratio和-XX:+UseAdaptiveSizePolicy

幸存区比例                -XX:SurviveRatio=ratio

晋升阈值                    -XX:MaxTrnuringThreshold=threshold

晋升详情                    -XX:+PrintTenuringDistribution

GC详情                      -XX:+PrintGCDetails-verbose:gc

FullGC前MinorGC -XX:+ScavengeBeforeFullGC

## 特殊机制

大对象直接晋升老年代

## 垃圾回收器

### 1.串行

**特点**：单线程；堆内存小，适合个人电脑

-XX:+UseSerialGC=Serial(新生代，标记+复制)+SerialOld（老年代，标记+整理）

### 2.吞吐量优先

**特点**：多线程，堆内存大，多核CPU，让单位时间内STW的时间最短

    -XX:+UseParrallelGC -XX:+UseParalellelOldGC
    -XX:+UseAdaptiveSizePolicy
    -XX:GCTimeRatio=Ratio
    垃圾回收的时间占正常运行的比例1/(1+ratio)
    -XX:MaxGCPauseMillis=ms
    GC暂停时间
    -XX:ParallelGCThreads=n

### 3.响应时间优先

**特点**：多线程；堆内存较大，多核CPU；尽可能缩减单次 STW时间

    -XX:+UseConcMarkSweepGC(工作在老年代) ~XX:+UsePareNewGC ~SerialOld(工作在老年代)
    -XX:ParallelGCThreads=n~ -XX:ConcGCThreads=threads
    //并行的垃圾回收线程数n
    //threads并发垃圾回收线程数
    -XX:CMSIntiatingOccupancyFraction=percent
    //当老年代的内存达到多少时进行垃圾回收，为解决单独的并发清理线程准备的
    -XX:+CMSScavengeBeforeRemark
    //对新生代做标记前进行一次垃圾回收

过程：初始标记（列举根对象）（全部阻塞），并发标记（标记垃圾）（一核运行标记），重新标记（再标记并发标记时产生的变化）（全部阻塞），并发清理（一核进行全部垃圾的清理），之后循环往复。</description><guid isPermaLink="true">https://hyjtab.github.io/post/14.html</guid><pubDate>Tue, 21 Jan 2025 15:53:34 +0000</pubDate></item><item><title>JVM学习</title><link>https://hyjtab.github.io/post/13.html</link><description># JVM内存结构

![Image](https://github.com/user-attachments/assets/542fa7e1-2750-4813-8030-0a871105c706)

## 虚拟机参数

-Xmx__ ：虚拟机堆内存大小

-XX:PrintStringTableStatistics ：字符串表详细信息

-XX:+PrintGCDetails：垃圾回收详细信息

-XX:StringTableSize=___: 桶个数

## 字节码

ldc 加载变量（把新的字符串符号变为字符串对象）

astore 存储到对应位置

aload 从对应位置加载

invokevirtual 调用虚函数

new 新建类对象

## 程序计数器寄存器

## 虚拟机栈

各个栈帧

## 堆空间

new出来的变量

字符串常量池

## 方法区

1. 类信息
  
2. 运行时常量池
  
3. 方法字节码
  
4. 编译后代码
  
5. 类加载器
  

## 常量池（存在于.class文件中）

就是一张为虚拟机指令提供的表，为字节码指令提供常量符号

## 运行时常量池

## StringTable

优点：相同字符串只有一个实例

字符串在用到的时候，才会加入StringTable实现上是一个hashTable，不能扩容。</description><guid isPermaLink="true">https://hyjtab.github.io/post/13.html</guid><pubDate>Mon, 20 Jan 2025 16:39:07 +0000</pubDate></item><item><title>Java 语法拾遗</title><link>https://hyjtab.github.io/post/12.html</link><description># String的不变性
相关题目：
```java
String a = 'hello, ';
String b = 'world!';
String c = 'hello, world!';
if(a + b == c) System.out.println('yes');//无输出
if('hello, ' + 'world!' == c) System.out.println('yes');//有输出
String a1 = new String('hello, ');
if (a1 == a ) System.out.println('yes');//无输出
StringBuilder sb1 = new StringBulider('nihao, ');
String s1 = sb1.toString();
StringBuilder sb2 = sb1;
sb1.append('Java!');
String s2 = sb1.toString();
if(s1 == s2) System.out.println('yes');//无输出
if(sb1 == sb2) System.out.println('yes');//有输出

String str1 = new StringBuilder('计算机').append('软件').toString();
System.out.println(str1.intern() == str1);//true
String str2 = new StringBuilder('ja').append('va').toString();
System.out.println(str2.intern() == str2);//false
```
## 原因
String本身是一个final修饰的类，同时其内容保存在value变量中，其属性为final修饰的私有成员变量。</description><guid isPermaLink="true">https://hyjtab.github.io/post/12.html</guid><pubDate>Sat, 18 Jan 2025 15:57:00 +0000</pubDate></item><item><title>go语言学习记录</title><link>https://hyjtab.github.io/post/11.html</link><description>## 1 := 与 =&#13;
:= 与下面的语句等价&#13;
```&#13;
var [变量] [类型]&#13;
[变量] = [值]&#13;
```&#13;
&#13;
## 2 go语言编译&#13;
先配置gopath环境变量，在项目根目录进行初始化&#13;
```&#13;
go mod init [模块名]&#13;
```&#13;
随后&#13;
```&#13;
go run&#13;
或者&#13;
go build -o [文件名].exe&#13;
```&#13;
&#13;
## 3 filepath.walk&#13;
walk func的标准定义：&#13;
```go&#13;
walkFn := func(path string, info os.FileInfo, err error) error&#13;
```。</description><guid isPermaLink="true">https://hyjtab.github.io/post/11.html</guid><pubDate>Mon, 13 Jan 2025 15:10:01 +0000</pubDate></item><item><title>GIT学习记录</title><link>https://hyjtab.github.io/post/10.html</link><description>## 1. git配置 ##&#13;
设置用户名与邮箱信息&#13;
```&#13;
git config --global user.name&#13;
git config --global user.email&#13;
```&#13;
设置命令行别名：&#13;
```&#13;
touch ~\.bashrc&#13;
```&#13;
随后在文件中写入以下命令别名&#13;
```&#13;
alias git-log='git log --pretty=oneline --all --graph --abbrev-commit'&#13;
alias ll='ls -al'&#13;
```&#13;
## 2. git本地仓库初始化 ##&#13;
很简单&#13;
```&#13;
git init&#13;
```&#13;
建立一个.git文件夹。</description><guid isPermaLink="true">https://hyjtab.github.io/post/10.html</guid><pubDate>Thu, 09 Jan 2025 16:42:22 +0000</pubDate></item><item><title>滑动窗口与双指针刷题记录</title><link>https://hyjtab.github.io/post/9.html</link><description># 滑动窗口&#13;
##定长窗口&#13;
&gt;[1652. 拆炸弹](https://leetcode.cn/problems/defuse-the-bomb/)&#13;
&gt;你有一个炸弹需要拆除，时间紧迫！你的情报员会给你一个长度为 n 的 循环 数组 code 以及一个密钥 k 。</description><guid isPermaLink="true">https://hyjtab.github.io/post/9.html</guid><pubDate>Fri, 08 Nov 2024 09:03:14 +0000</pubDate></item><item><title>阶段刷题总结（二分法与滑动窗口）</title><link>https://hyjtab.github.io/post/8.html</link><description># 写在前面&#13;
经过向学长请教，每日一题还是放下来，之后再跟，先按顺序刷题库，遇到陌生的知识点再对其进行深搜，等到有一定的知识储备之后再去跟每日一题。</description><guid isPermaLink="true">https://hyjtab.github.io/post/8.html</guid><pubDate>Tue, 05 Nov 2024 08:32:26 +0000</pubDate></item><item><title>20241029每日一题(位运算/动规/模拟/深搜)</title><link>https://hyjtab.github.io/post/7.html</link><description>&gt;[3211. 生成不含相邻零的二进制字符串](https://leetcode.cn/problems/generate-binary-strings-without-adjacent-zeros/)&#13;
&gt;给你一个正整数 n。</description><guid isPermaLink="true">https://hyjtab.github.io/post/7.html</guid><pubDate>Tue, 29 Oct 2024 10:13:58 +0000</pubDate></item><item><title>20241028每日一题</title><link>https://hyjtab.github.io/post/6.html</link><description>&gt;[685. 冗余连接 II](https://leetcode.cn/problems/redundant-connection-ii/)&#13;
&gt;在本问题中，有根树指满足以下条件的 有向 图。</description><guid isPermaLink="true">https://hyjtab.github.io/post/6.html</guid><pubDate>Mon, 28 Oct 2024 17:23:46 +0000</pubDate></item><item><title>Windows开机启动项设置</title><link>https://hyjtab.github.io/post/5.html</link><description># windows开机启动项配置&#13;
1.win+R启动控制台&#13;
2.键入 shell：startup &#13;
3.找到需要开机启动的程序&#13;
4.创建快捷方式拖入刚才打开的窗口。</description><guid isPermaLink="true">https://hyjtab.github.io/post/5.html</guid><pubDate>Mon, 28 Oct 2024 07:45:23 +0000</pubDate></item><item><title>第0章到第4章小结</title><link>https://hyjtab.github.io/post/4.html</link><description># 第0章&#13;
1. 给出一个最短的c++有效程序：&#13;
```&#13;
int main(){}&#13;
```&#13;
# 第1章&#13;
2. iostream库中cin的字符串读取，自动省略开头空白字符，并在之后遇到空白字符（包括空格）就会截止&#13;
&#13;
3. string初始化（库函数小括号初始化方式）(num,value)&#13;
&#13;
4. 第一段定义有效，第二段定义无效，因为字符串常量未实现+运算符重载：&#13;
```cpp&#13;
const std::string hello = 'Hello';&#13;
const std::string message = hello + ', world' + '!';&#13;
\\上面一行的中间结果会返回一个string类型的中间变量，继续和'!'做加法。</description><guid isPermaLink="true">https://hyjtab.github.io/post/4.html</guid><pubDate>Sun, 27 Oct 2024 09:48:46 +0000</pubDate></item><item><title>leetcode每日一题20241027（并查集）</title><link>https://hyjtab.github.io/post/3.html</link><description># 每日一题&#13;
&gt;[684. 冗余连接](https://leetcode.cn/problems/redundant-connection/)&#13;
&#13;
&gt;树可以看成是一个连通且无环的无向图。</description><guid isPermaLink="true">https://hyjtab.github.io/post/3.html</guid><pubDate>Sun, 27 Oct 2024 07:55:49 +0000</pubDate></item><item><title>每日一题20241026（零一背包与bitset）</title><link>https://hyjtab.github.io/post/2.html</link><description># 每日一题（零一背包与bitset）&#13;
&gt; Leetcode 3181. 执行操作可获得的最大总奖励 II&#13;
&gt; 给你一个整数数组 rewardValues，长度为 n，代表奖励的值。</description><guid isPermaLink="true">https://hyjtab.github.io/post/2.html</guid><pubDate>Sat, 26 Oct 2024 12:46:05 +0000</pubDate></item><item><title>新阶段新博客</title><link>https://hyjtab.github.io/post/1.html</link><description># 新阶段新博客&#13;
读研了，审美风格和想法相较之前有了一些变化，就采用了最省力的办法来写博客。</description><guid isPermaLink="true">https://hyjtab.github.io/post/1.html</guid><pubDate>Fri, 25 Oct 2024 13:52:56 +0000</pubDate></item></channel></rss>